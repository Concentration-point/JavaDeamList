核心思想是复用线程，创建好线程之后加入线程队列中(线程池)
由于分为核心线程和辅助线程，所以有两个线程队列`coreList`和`supportList`

采用阻塞队列作为任务队列，每次新建线程执行完任务之后都从任务队列中获取任务，利用阻塞队列的特性，如果里面没有任务就会阻塞，不会耗费我们的CPU

任务提交流程：
任务数小于corePoolSize，创建核心线程执行任务
任务数>=corePoolSize，且任务队列没满，加入任务队列中
任务数>=corePoolSize && < maxsize 且任务队列已满，创建辅助线程执行任务
任务数 > maxsize 且任务队列已满，执行拒绝策略

向阻塞队列`blockingQueue`中添加任务使用`offer()`，而不是`add()`，`offer()`会返回一个布尔值，可以通过该值判断是否添加成功

辅助线程空闲销毁实现：
```java
Runnable command = blockingQueue.poll(timeout, timeUnit);  
if (command == null) {  
    break;
```
`poll()`可以做到如果在任务队列中一定时间内没获取到任务返回null，判断该值则跳出循环，让线程自动销毁即可。



对于核心线程类做的只有两件事：
1. 执行提交的任务
2. 完成后循环的在任务队列中获取任务（遵循阻塞队列规则）

辅助线程类类似。